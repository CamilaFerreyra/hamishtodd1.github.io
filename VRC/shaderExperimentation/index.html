<html>
<head>
    <style>
    	body{
    		margin: 0;
    		overflow: hidden;
    	}
    </style>
</head>
<body>

<canvas id="myCanvas"></canvas>

<script src="three.min.js"></script>

<script type="x-shader/x-vertex" id="vertexShader">
	void main() 
	{
		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	}
</script>
<script type="x-shader/x-fragment" id="fragmentShader">
	void main()
	{
		gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
	}
</script>

<script type="x-shader/x-vertex" id="vertexShader2">
	attribute float vertexDisplacement;
	varying float vOpacity;
	varying vec3 vUv;
	uniform float delta;

	void main() 
	{
		vUv = position;
		vOpacity = vertexDisplacement;

		vec3 p = position;

		p.x += sin(vertexDisplacement*10.0) * 50.0;
		p.y += cos(vertexDisplacement*10.0) * 50.0;

		vec4 modelViewPosition = modelViewMatrix * vec4(p, 1.0);
		gl_Position = projectionMatrix * modelViewPosition;
	}
</script>

<script type="x-shader/x-fragment" id="fragmentShader2">
	uniform float delta;
	varying float vOpacity;
	varying vec3 vUv;

	void main() {

		float r = 1.0 + cos(vUv.x * delta);
		float g = 0.5 + sin(delta) * 0.5;
		float b = 0.0;
		vec3 rgb = vec3(r, g, b);

		gl_FragColor = vec4(rgb, 0.1);
	}
</script>


<script>

    var renderer,
    	scene,
    	camera,
    	myCanvas = document.getElementById('myCanvas');

    //RENDERER
    renderer = new THREE.WebGLRenderer({
      canvas: myCanvas, 
      antialias: true
    });
    renderer.setClearColor(0xffffff);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);

    //CAMERA
    camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 300, 10000 );

    //SCENE
    scene = new THREE.Scene();
    
    //Custom Shader Material
	var whichMaterial = 2;
	if(whichMaterial === 2)
	{
		var customUniforms = {
        delta: {value: 0}
		};
		var material = new THREE.ShaderMaterial({
			uniforms: customUniforms,
			vertexShader: document.getElementById('vertexShader2').textContent,
			fragmentShader: document.getElementById('fragmentShader2').textContent
		});
	}
	else
	{
		var material = new THREE.ShaderMaterial({
			uniforms: [],
			vertexShader: document.getElementById('vertexShader').textContent,
			fragmentShader: document.getElementById('fragmentShader').textContent
		});
	}
    
    var box = new THREE.Mesh(new THREE.BoxBufferGeometry(100, 100, 100, 10, 10, 10), material);
    box.position.z = -1000;
    box.position.x = -100;
    scene.add(box);

    var sphere = new THREE.Mesh(new THREE.SphereGeometry(50, 20, 20), material);
    sphere.position.z = -1000;
    sphere.position.x = 100;
    scene.add(sphere);

    var plane = new THREE.Mesh(new THREE.PlaneGeometry(10000, 10000, 100, 100), material);
    plane.rotation.x = -90 * Math.PI / 180;
    plane.position.y = -100;
    scene.add(plane);

    //attribute
    var vertexDisplacement = new Float32Array(box.geometry.attributes.position.count);

    for (var i = 0; i < vertexDisplacement.length; i ++) {
        vertexDisplacement[i] = Math.sin(i);
    }

    box.geometry.addAttribute('vertexDisplacement', new THREE.BufferAttribute(vertexDisplacement, 1));

    //RENDER LOOP
    render();

    var delta = 0;
    function render() {

        delta += 0.0005;

        //uniform
		if(whichMaterial === 2)
			material.uniforms.delta.value = 0.5 + Math.sin(delta) * 0.5;

        //attribute
        for (var i = 0, il = vertexDisplacement.length; i < il; i ++) {
            vertexDisplacement[i] = 0.5 + Math.sin(i + delta) * 0.25;
        }
        box.geometry.attributes.vertexDisplacement.needsUpdate = true;

    	renderer.render(scene, camera);

    	requestAnimationFrame(render);
    }

    </script>
</body>
</html>
