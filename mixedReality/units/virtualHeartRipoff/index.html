<!-- 
	Might be good to try to get a threejs canvas in and try to render to that

	So he has some shader that is able to take

	At least be able to write your own
	Better, be able to copypaste this guy's code and stick his 2D ones on a texture
	Even better, replicate 3D ones such that your hand can be in there
	Ideally extract the "pixel" values, in either vertex or fragment shader, then do something with them

	It's a bufferAttribute
	But how to take control of them? Very speculative, but maybe have some uniform that is where the hand is
 -->

<html><head>
<script src="CanvasMatrix.js" type="text/javascript"></script>

<script id="renderingVertexShader" type="x-shader/x-vertex"> 
	attribute vec3 aPos;
	uniform bool path;
	uniform float pSize;
	uniform mat4 mvMatrix;
	uniform mat4 prMatrix;
	uniform sampler2D samp;
	varying vec3 color;
	const float n = 128., ny = 64., dx = 1./n, dy = 1./ny, dz = dy/n, Uth = .5;
void main(void)
{
	vec4 t = texture2D(samp, vec2(aPos.x, aPos.y + aPos.z*dy ));
	gl_PointSize = pSize;
	if( !path )
	{
		if (t.r < .7) gl_Position = vec4(1000.,0.,0.,1.);
		else gl_Position = prMatrix * mvMatrix *
			vec4( aPos.x - .5, .5*(aPos.y - .5), aPos.z - .5, 1.);
		color = vec3(.5*t.r, 3.*t.g, 0. );
		return;}

	float x1 = aPos.x + dx;
	if(x1 > 1.) x1 = aPos.x;
	float y1 = aPos.y + dy;
	if(y1 + dy >= 1.) y1 = aPos.y;
	float z1 = aPos.z + dx;
	if(z1 > 1.) z1 = aPos.z;
	z1 *= dy;
	float v =
		step(Uth, texture2D(samp, vec2(aPos.x, aPos.y + aPos.z*dy) ).r) +
		step(Uth, texture2D(samp, vec2(x1,     aPos.y + aPos.z*dy) ).r) +
		step(Uth, texture2D(samp, vec2(aPos.x, aPos.y + z1) ).r) +
		step(Uth, texture2D(samp, vec2(x1,     aPos.y + z1) ).r) +
		step(Uth, texture2D(samp, vec2(aPos.x, y1 + aPos.z*dy) ).r) +
		step(Uth, texture2D(samp, vec2(x1,     y1 + aPos.z*dy) ).r) +
		step(Uth, texture2D(samp, vec2(aPos.x, y1 + z1) ).r) +
		step(Uth, texture2D(samp, vec2(x1,     y1 + z1) ).r);
	bool bv = (v > .5) && (v < 7.5);
	v =
		step(.0, texture2D(samp, vec2(aPos.x, aPos.y + aPos.z*dy) ).b) +
		step(.0, texture2D(samp, vec2(x1,     aPos.y + aPos.z*dy) ).b) +
		step(.0, texture2D(samp, vec2(aPos.x, aPos.y + z1) ).b) +
		step(.0, texture2D(samp, vec2(x1,     aPos.y + z1) ).b) +
		step(.0, texture2D(samp, vec2(aPos.x, y1 + aPos.z*dy) ).b) +
		step(.0, texture2D(samp, vec2(x1,     y1 + aPos.z*dy) ).b) +
		step(.0, texture2D(samp, vec2(aPos.x, y1 + z1) ).b) +
		step(.0, texture2D(samp, vec2(x1,     y1 + z1) ).b);
	bool bdv = (v > .5) && (v < 7.5);

	if ( aPos.y == 0.)
	{
		color = vec3(.5*t.r, 3.*t.g, 0. );
		gl_Position = prMatrix * mvMatrix *
				vec4( aPos.x - .5, .5*(aPos.y - .5), aPos.z - .5, 1.);
		return;}
	if ( !(bv && bdv) ) gl_Position = vec4(1000.,0.,0.,1.);
	else gl_Position = prMatrix * mvMatrix *
		vec4( aPos.x - .5, .5*(aPos.y - .5), aPos.z - .5, 1.);
	color = vec3(1.);

}
</script> 
 
<script id="renderingFragmentShader" type="x-shader/x-fragment"> 
precision highp float;
	varying vec3 color;
void main(void)
{
	gl_FragColor = vec4(color, 1.);
}
</script> 

<script id="simulationVertexShader" type="x-shader/x-vertex"> 
	attribute vec3 aPos2;
	attribute vec2 aTexCoord;
	varying   vec2 tc;
void main(void)
{
	gl_Position = vec4(aPos2, 1.);
	tc = aTexCoord;
}
</script> 

<script id="simulationFragmentShader" type="x-shader/x-fragment"> 
precision highp float;
	uniform sampler2D samp2;
	uniform float dt;
	uniform float dth2;
	uniform float a;
	uniform float b;
	uniform float eps;
	varying vec2 tc;
	const float n = 128., ny = 64., dx = 1./n, dy = 1./ny, dz = dy/n;
void main(void)
{
	vec4 t = texture2D(samp2, tc);
	float u = t.r,  v = t.g;
	float du = dt*(u*(1.0 - u)*(u - a) - v);
	float vnew = v + dt*eps*(b*u - v);
	float dym = tc.y - dy;  // clamp y
	if(dym < 0.) dym = tc.y;
	float dyp = tc.y + dy;
	if(dyp > 1.) dyp = tc.y;

	float z = mod(tc.y, dy);  // clamp z
	float dzm = z - dz;
	if(dzm < 0.) dzm = tc.y;
	else dzm = tc.y - dz;
	float dzp = z + dz;
	if(dzp > dy) dzp = tc.y;
	else dzp = tc.y + dz;
	du += (
			texture2D(samp2, vec2(tc.x, dyp) ).r +
			texture2D(samp2, vec2(tc.x, dym) ).r +
			texture2D(samp2, vec2(tc.x, dzp) ).r +
			texture2D(samp2, vec2(tc.x, dzm) ).r +
			texture2D(samp2, vec2(tc.x + dx, tc.y) ).r +
			texture2D(samp2, vec2(tc.x - dx, tc.y) ).r +
			- 6.*u)*dth2;
	gl_FragColor = vec4(u + du, vnew, du, 0. );
}
</script> 
 
<script type="text/javascript"> 

var gl, canvas, canvasWidth, canvasHeight,
	prog, prog2, texture, texture2, FBO, FBO2, mvMat, mvMatLoc, rotMat,
	xOffs = yOffs = 0,  drag  = 0,  xRot = yRot = 0,  transl = -2.,
	n = 128, ny = 64,  it = 1, animating = true,
	a = .1, b = .2, eps = .05, D = 1,
	dt = .5, h = 2;

function generateStartingPixels()
{
	var pixels = [];
	for(var y = 0; y < ny; y++)
	for(var z = 0; z < n; z++)
	for(var x = 0; x < n; x++)
	{
		if( z > n/2 )
		{
			var t = (x + .2*y - n/2)*.1,  t2 = t - 2;
			pixels.push( 1*Math.exp(-t*t), .5*Math.exp(-t2*t2) );
		}
		else pixels.push( 0, 0 );
		pixels.push( 0, 0 );
	}
	return pixels
}

function webGlStart()
{
	function getShader ( gl, id )
	{
		var shaderScript = document.getElementById ( id );
		var str = "";
		var k = shaderScript.firstChild;
		while ( k )
		{
			if ( k.nodeType == 3 ) str += k.textContent;
			k = k.nextSibling;
		}

		//very much equivalent to our stuff at this point, just a string

		var shader;
		if ( shaderScript.type == "x-shader/x-fragment" )
		{
			shader = gl.createShader ( gl.FRAGMENT_SHADER );
		}
		else if ( shaderScript.type == "x-shader/x-vertex" )
		{
			shader = gl.createShader(gl.VERTEX_SHADER);
		}
		else
		{
			return null;
		}
		gl.shaderSource(shader, str);
		gl.compileShader(shader);
		if (gl.getShaderParameter(shader, gl.COMPILE_STATUS) == 0)
		{
			alert(gl.getShaderInfoLog(shader));
		}
		return shader;
	}

	canvas = document.getElementById("canvas");
	canvasWidth = window.innerWidth - 50;
	canvasHeight = window.innerHeight - 10;
	canvas.width = canvasWidth;
	canvas.height = canvasHeight;

	//compatibility
	{
		var err = "Your browser does not support ";
		if (!window.WebGLRenderingContext)
		{
			alert(err+"WebGL. See http://get.webgl.org");
			return;}
		try { gl = canvas.getContext("experimental-webgl");
		} catch(e)
		{}
		if ( !gl )
			{alert("Can't get WebGL"); return;}
		if (gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS) == 0)
		{
			alert(err + "Vertex texture"); return;}
		var ext;
		try { ext = gl.getExtension("OES_texture_float");
		} catch(e)
		{}
		if ( !ext )
			{alert(err + "OES_texture_float extension"); return;}
	}

	//renderering, snore
	{
		prog  = gl.createProgram();
		gl.attachShader(prog, getShader( gl, "renderingVertexShader" ));
		gl.attachShader(prog, getShader( gl, "renderingFragmentShader" ));
		gl.linkProgram(prog);
		gl.useProgram(prog);

		function render()
		{
			gl.viewport(0, 0, canvasWidth, canvasHeight);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
			gl.useProgram(prog);
			rotMat.rotate(xRot/3, 1,0,0);  rotMat.rotate(yRot/3, 0,1,0);
			yRot = 0;  xRot = 0;
			mvMatrix.load( rotMat );
			mvMatrix.translate(0, 0, transl);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			gl.uniformMatrix4fv( mvMatLoc, false,
				new Float32Array(mvMatrix.getAsArray()) );

			gl.drawArrays(gl.POINTS, 0, n*ny*n);
			gl.flush ();
		}
		
		var vertices = [];
		for ( var y = 0; y < ny; y++ )
		for ( var z = 0; z < n; z++ )
		for ( var x = 0; x < n; x++ )
		{
			vertices.push ( (x+.5)/n, y/ny, (z+.5)/n );
		}
		var aPosLoc = gl.getAttribLocation(prog, "aPos");
		gl.enableVertexAttribArray( aPosLoc );
		gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		gl.vertexAttribPointer(aPosLoc, 3, gl.FLOAT, false, 0, 0);

		gl.uniform1i(gl.getUniformLocation(prog, "samp"), 0);
		gl.uniform1i(gl.getUniformLocation(prog, "path"), 1);
		gl.uniform1f(gl.getUniformLocation(prog, "pSize"), 5);
	}

	//starting the simulation maybe?
	{
		let pixels = generateStartingPixels()

		texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, n, ny*n, 0,
			gl.RGBA, gl.FLOAT, new Float32Array(pixels));
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		texture2 = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, texture2);
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, n, ny*n, 0, gl.RGBA,
				gl.FLOAT, new Float32Array(pixels));
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
	}

	//projection and rotation
	{
		var prMatrix = new CanvasMatrix4();
		prMatrix.perspective(45, canvasWidth/canvasHeight, .1, 100);
		gl.uniformMatrix4fv( gl.getUniformLocation(prog,"prMatrix"),
				false, new Float32Array(prMatrix.getAsArray()) );
		mvMatrix = new CanvasMatrix4();
		rotMat = new CanvasMatrix4();
		rotMat.makeIdentity();
		rotMat.rotate(10, 1,0,0);
		mvMatLoc = gl.getUniformLocation(prog,"mvMatrix");
	}

	//the simulation
	{
		prog2  = gl.createProgram();
		gl.attachShader(prog2, getShader( gl, "simulationVertexShader" ));
		gl.attachShader(prog2, getShader( gl, "simulationFragmentShader" ));
		var aPos2Loc = 1;
		gl.bindAttribLocation(prog2, aPos2Loc, "aPos2");
		var aTexLoc = 2;
		gl.bindAttribLocation(prog2, aTexLoc, "aTexCoord");
		gl.linkProgram(prog2);
		gl.useProgram(prog2);
		gl.enableVertexAttribArray( aPos2Loc );
		gl.enableVertexAttribArray( aTexLoc );
		gl.uniform1i(gl.getUniformLocation(prog2, "samp2"), 0);
		gl.uniform1f(gl.getUniformLocation(prog2, "a"), a);
		gl.uniform1f(gl.getUniformLocation(prog2, "b"), b);
		gl.uniform1f(gl.getUniformLocation(prog2, "eps"), eps);
		gl.uniform1f(gl.getUniformLocation(prog2, "dt"),  dt);
		gl.uniform1f(gl.getUniformLocation(prog2, "dth2"), D*dt/(h*h));

		function updateSimulation()
		{
			gl.viewport(0,0,n,ny*n);
			gl.useProgram(prog2);
			for(var i = 0; i < it; i++)
			{
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.bindFramebuffer(gl.FRAMEBUFFER, FBO2);
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

				gl.bindTexture(gl.TEXTURE_2D, texture2);
				gl.bindFramebuffer(gl.FRAMEBUFFER, FBO);
				gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
			}
		}
	}

	//the texture at the bottom?
	{
		gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
		var vertices = new Float32Array([-1,-1,0, 1,-1,0, -1,1,0, 1,1,0]);
		var texCoords = new Float32Array([0,0, 1,0, 0,1, 1,1]);
		var texCoordOffset = vertices.byteLength;
		gl.bufferData(gl.ARRAY_BUFFER,
				texCoordOffset + texCoords.byteLength, gl.STATIC_DRAW);
		gl.bufferSubData(gl.ARRAY_BUFFER, 0, vertices);
		gl.bufferSubData(gl.ARRAY_BUFFER, texCoordOffset, texCoords);
		gl.vertexAttribPointer(aPos2Loc, 3, gl.FLOAT, gl.FALSE, 0, 0);
		gl.vertexAttribPointer(aTexLoc, 2, gl.FLOAT, gl.FALSE, 0, texCoordOffset);
	}

	//not sure
	{
		FBO = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, FBO);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
			gl.TEXTURE_2D, texture, 0);
		FBO2 = gl.createFramebuffer();
		gl.bindFramebuffer(gl.FRAMEBUFFER, FBO2);
		gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
			gl.TEXTURE_2D, texture2, 0);
		if( gl.checkFramebufferStatus(gl.FRAMEBUFFER) != gl.FRAMEBUFFER_COMPLETE )
		{
			alert(err + "FLOAT as the color attachment to an FBO");
		}
	}

	//boilerplate?
	{
		gl.enable(gl.DEPTH_TEST);
		gl.depthFunc(gl.LEQUAL);
		gl.clearDepth(1.0);
		gl.clearColor(0, 0, .2, 1);
	}

	//mouse
	{
		canvas.onmousedown = function ( ev )
		{
			drag  = 1;
			xOffs = ev.clientX;  yOffs = ev.clientY;
		}
		canvas.onmouseup = function ( ev )
		{
			drag  = 0;
			xOffs = ev.clientX;  yOffs = ev.clientY;
		}
		canvas.onmousemove = function ( ev )
		{
			if ( drag == 0 ) return;
			if ( ev.shiftKey )
			{
				transl *= 1 + (ev.clientY - yOffs)/300;
				yRot = - xOffs + ev.clientX;
			}
			else
			{
				yRot = - xOffs + ev.clientX;  xRot = - yOffs + ev.clientY;
			}
			xOffs = ev.clientX;   yOffs = ev.clientY;
		}
		var wheelHandler = function(ev)
		{
			var del = 1.1;
			if (ev.shiftKey) del = 1.01;
			var ds = ((ev.detail || ev.wheelDelta) < 0) ? del : (1 / del);
			transl *= ds;
			ev.preventDefault();
		};
		canvas.addEventListener('DOMMouseScroll', wheelHandler, false);
		canvas.addEventListener('mousewheel', wheelHandler, false);
	}

	function loop()
	{
		if( animating )
		{
			updateSimulation();
		}

		render()
		requestAnimationFrame(loop)
	}

	loop();
}

function toggleRunning()
{
	if( animating )
	{
		animating = false
		document.getElementById('runBtn').value = "Run ";}
	else{
		animating = true
		document.getElementById('runBtn').value = "Stop";
	}
}
function reset()
{
	var pixels = generateStartingPixels();

	gl.bindTexture(gl.TEXTURE_2D, texture);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, n, ny*n, 0,
		gl.RGBA, gl.FLOAT, new Float32Array(pixels));

	gl.bindTexture(gl.TEXTURE_2D, texture2);
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, n, ny*n, 0, gl.RGBA,
		gl.FLOAT, new Float32Array(pixels));

	animating = true
	document.getElementById('runBtn').value = "Stop";
}

function setA(v)
{
	gl.useProgram(prog2);
	gl.uniform1f(gl.getUniformLocation(prog2, "a"), parseFloat(v));
}
function setB(v)
{
	gl.useProgram(prog2);
	gl.uniform1f(gl.getUniformLocation(prog2, "b"), parseFloat(v));
}
function setEps(v)
{
	gl.useProgram(prog2);
	gl.uniform1f(gl.getUniformLocation(prog2, "eps"), parseFloat(v));
}
function setDt(v)
{
	dt = parseFloat(v);
	gl.useProgram(prog2);
	gl.uniform1f(gl.getUniformLocation(prog2, "dt"), dt);
	gl.uniform1f(gl.getUniformLocation(prog2, "dth2"), D*dt/(h*h));
}
function setH(v)
{
	h = parseFloat(v);
	gl.useProgram(prog2);
	gl.uniform1f(gl.getUniformLocation(prog2, "dth2"), D*dt/(h*h));
}
function setPathOrIsoSurface(v)
{
	gl.finish();
	gl.useProgram(prog);
	gl.uniform1i(gl.getUniformLocation(prog, "path"), v);
}
function setPointSize(v)
{
	var si = parseInt(v);
	gl.useProgram(prog);
	gl.uniform1f(gl.getUniformLocation(prog, "pSize"), si);
}
</script>
</head>
<body onload="webGlStart();"> 

<canvas id="canvas" width="500" height="500"></canvas> 
<br><button onclick="reset()">Reset</button>
<input type="button" onclick="toggleRunning()" value="Stop" size="1" id="runBtn">
<input type="checkbox" onclick="setPathOrIsoSurface(checked);" checked>path
a<input size="2" value="0.1" onchange="setA(this.value)">
b<input size="2" value="0.2" onchange="setB(this.value)">
&epsilon;<input size="2" value="0.05" onchange="setEps(this.value)">
dt<input size="2" value="0.5" onchange="setDt(this.value)">
dx<input size="2" value="2" onchange="setH(this.value)">
ptSize<input size="2" value="5" onchange="setPointSize(this.value)">
it<input size="2" value="10" onchange="it=parseInt(this.value)">


</body></html>