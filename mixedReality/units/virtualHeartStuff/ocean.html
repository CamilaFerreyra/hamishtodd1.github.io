<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<script src="../../lib/three.js"></script>

		<script src="OceanShaders.js"></script>

		<script>

			let clock = new THREE.Clock( true );
			let frameDelta = 0;

			let renderer = new THREE.WebGLRenderer();
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.context.getExtension( 'OES_texture_float' );
			renderer.context.getExtension( 'OES_texture_float_linear' );
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			let scene = new THREE.Scene();

			let camera = new THREE.PerspectiveCamera( 55.0, window.innerWidth / window.innerHeight, 0.5, 300000 );
			camera.position.set( 450, 350, 450 );
			camera.lookAt( 0, 0, 0 );

			THREE.Ocean = function ( renderer, camera, actualScene )
			{
				const geometrySize = 512 //display only
				const resolution = 1024 //number of sim points wide
				const geometryResolution = resolution / 2 //probably specific to this sim
				const size = 256.0 //size in the virtual world

				const sunDirectionX = -1.0
				const sunDirectionY = 1.0
				const sunDirectionZ = 1.0
				const waterColor = new THREE.Vector3( 0.004, 0.016, 0.047 )
				const skyColor = new THREE.Vector3( 3.2, 9.6, 12.8 )
				const exposure = 0.35
				const windX = 10.0
				const windY = 10.0
				const choppiness = 1.5

				// parameter change flags
				let changed = true;
				let initial = true;

				let pingPhase = true;
				let simScene = new THREE.Scene();
				let simCamera = new THREE.OrthographicCamera();
				simCamera.position.z = 1;
				renderer.clearColor( 0xffffff );

				// framebuffers
				{
					var LinearClampParams = {
						minFilter: THREE.LinearFilter,
						magFilter: THREE.LinearFilter,
						wrapS: THREE.ClampToEdgeWrapping,
						wrapT: THREE.ClampToEdgeWrapping
					};
					var NearestClampParams = {
						minFilter: THREE.NearestFilter,
						magFilter: THREE.NearestFilter,
						wrapS: THREE.ClampToEdgeWrapping,
						wrapT: THREE.ClampToEdgeWrapping
					};
					var NearestRepeatParams = {
						minFilter: THREE.NearestFilter,
						magFilter: THREE.NearestFilter,
						wrapS: THREE.RepeatWrapping,
						wrapT: THREE.RepeatWrapping
					};
					let paramses = [NearestRepeatParams, NearestClampParams,LinearClampParams]
					for(let i = 0; i < 3; i++)
					{
						paramses[i].format = THREE.RGBAFormat
						paramses[i].stencilBuffer = false
						paramses[i].depthBuffer = false
						paramses[i].premultiplyAlpha = false
						paramses[i].type = THREE.FloatType //THREE.HalfFloatType
					}
					var initialSpectrumFramebuffer	 = new THREE.WebGLRenderTarget( resolution, resolution, NearestRepeatParams );
					var spectrumFramebuffer			 = new THREE.WebGLRenderTarget( resolution, resolution, NearestClampParams );
					var pingPhaseFramebuffer		 = new THREE.WebGLRenderTarget( resolution, resolution, NearestClampParams );
					var pongPhaseFramebuffer		 = new THREE.WebGLRenderTarget( resolution, resolution, NearestClampParams );
					var pingTransformFramebuffer	 = new THREE.WebGLRenderTarget( resolution, resolution, NearestClampParams );
					var pongTransformFramebuffer	 = new THREE.WebGLRenderTarget( resolution, resolution, NearestClampParams );
					var displacementMapFramebuffer	 = new THREE.WebGLRenderTarget( resolution, resolution, LinearClampParams );
					var normalMapFramebuffer		 = new THREE.WebGLRenderTarget( resolution, resolution, LinearClampParams );
				}

				// Shaders and constant uniforms
				{
					// 1 - Horizontal wave vertices used for FFT
					var windHorizontalShader = THREE.ShaderLib[ "ocean_subtransform" ];
					var materialWindHorizontal = new THREE.ShaderMaterial( {
						uniforms: THREE.UniformsUtils.clone( windHorizontalShader.uniforms ),
						vertexShader: THREE.ShaderLib[ "alwaysUsedVertexShader" ].vertexShader,
						fragmentShader: "#define HORIZONTAL \n" + windHorizontalShader.fragmentShader
					} );
					materialWindHorizontal.uniforms.u_transformSize = { value: resolution };
					materialWindHorizontal.uniforms.u_subtransformSize = { value: null };
					materialWindHorizontal.uniforms.u_input = { value: null };

					// 2 - Vertical wave vertices used for FFT
					var windVerticalShader = THREE.ShaderLib[ "ocean_subtransform" ];
					var materialWindVertical = new THREE.ShaderMaterial( {
						uniforms: THREE.UniformsUtils.clone( windVerticalShader.uniforms ),
						vertexShader: THREE.ShaderLib[ "alwaysUsedVertexShader" ].vertexShader,
						fragmentShader: windVerticalShader.fragmentShader
					} );
					materialWindVertical.uniforms.u_transformSize = { value: resolution };
					materialWindVertical.uniforms.u_subtransformSize = { value: null };
					materialWindVertical.uniforms.u_input = { value: null };

					// 3 - Initial spectrum used to generate height map
					var initialSpectrumShader = THREE.ShaderLib[ "ocean_initial_spectrum" ];
					var materialInitialSpectrum = new THREE.ShaderMaterial( {
						uniforms: THREE.UniformsUtils.clone( initialSpectrumShader.uniforms ),
						vertexShader: initialSpectrumShader.vertexShader,
						fragmentShader: initialSpectrumShader.fragmentShader
					} );
					materialInitialSpectrum.uniforms.u_wind = { value: new THREE.Vector2() };
					materialInitialSpectrum.uniforms.u_resolution = { value: resolution };

					// 4 - Phases used to animate heightmap
					var materialPhase = new THREE.ShaderMaterial( {
						uniforms: THREE.UniformsUtils.clone( THREE.ShaderLib[ "ocean_phase" ].uniforms ),
						vertexShader: THREE.ShaderLib[ "alwaysUsedVertexShader" ].vertexShader,
						fragmentShader: THREE.ShaderLib[ "ocean_phase" ].fragmentShader
					} );
					materialPhase.uniforms.u_resolution = { value: resolution };

					// 5 - Shader used to update spectrum
					var materialSpectrum = new THREE.ShaderMaterial( {
						uniforms: THREE.UniformsUtils.clone( THREE.ShaderLib[ "ocean_spectrum" ].uniforms ),
						vertexShader: THREE.ShaderLib[ "alwaysUsedVertexShader" ].vertexShader,
						fragmentShader: THREE.ShaderLib[ "ocean_spectrum" ].fragmentShader
					} );
					materialSpectrum.uniforms.u_initialSpectrum = { value: null };
					materialSpectrum.uniforms.u_resolution = { value: resolution };

					// 6 - Shader used to update spectrum normals
					var materialNormal = new THREE.ShaderMaterial( {
						uniforms: THREE.UniformsUtils.clone( THREE.ShaderLib[ "ocean_normals" ].uniforms ),
						vertexShader: THREE.ShaderLib[ "alwaysUsedVertexShader" ].vertexShader,
						fragmentShader: THREE.ShaderLib[ "ocean_normals" ].fragmentShader
					} );
					materialNormal.uniforms.u_displacementMap = { value: null };
					materialNormal.uniforms.u_resolution = { value: resolution };

					// 7 - Shader used to update normals
					var materialDisplay = new THREE.ShaderMaterial( {
						uniforms: THREE.UniformsUtils.clone( THREE.ShaderLib[ "oceanDisplay" ].uniforms ),
						vertexShader: THREE.ShaderLib[ "oceanDisplay" ].vertexShader,
						fragmentShader: THREE.ShaderLib[ "oceanDisplay" ].fragmentShader
					} );
					materialDisplay.uniforms.u_geometrySize = { value: resolution };
					materialDisplay.uniforms.u_displacementMap = { value: displacementMapFramebuffer.texture };
					materialDisplay.uniforms.u_normalMap = { value: normalMapFramebuffer.texture };
					materialDisplay.uniforms.u_waterColor = { value: waterColor };
					materialDisplay.uniforms.u_skyColor = { value: skyColor };
					materialDisplay.uniforms.u_sunDirection = { value: new THREE.Vector3( sunDirectionX, sunDirectionY, sunDirectionZ ) };
					materialDisplay.uniforms.u_exposure = { value: exposure };
					materialDisplay.uniforms.u_size.value = size;
					materialDisplay.uniforms.u_projectionMatrix = { value: camera.projectionMatrix };
					materialDisplay.uniforms.u_viewMatrix = { value: camera.matrixWorldInverse };
					materialDisplay.uniforms.u_cameraPosition = { value: camera.position };

					let all = [materialDisplay,materialNormal,materialSpectrum,materialPhase,materialInitialSpectrum,windVerticalShader,windHorizontalShader]
					for(let i = 0; i < all.length; i++)
					{
						all[i].blending = 0; //prevent default premultiplied alpha values
						all[i].depthTest = false;
					}
					materialDisplay.depthTest = true
				}

				let simulationMesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2, 2 ), materialPhase );
				simScene.add( simulationMesh );

				let displayMesh = new THREE.Mesh(
					new THREE.PlaneBufferGeometry( geometrySize, geometrySize, geometryResolution, geometryResolution ).rotateX( - Math.PI / 2 ),
					materialDisplay );
				actualScene.add( displayMesh );

				//---------------------

				function updateSimulation()
				{
					var nonSimulationRenderTarget = renderer.getRenderTarget();

					if( changed )
					{
						generateInitialSpectrum();
					}

					renderWhole()

					renderer.setRenderTarget( nonSimulationRenderTarget );
				};

				function generateInitialSpectrum()
				{
					simScene.overrideMaterial = materialInitialSpectrum;
					materialInitialSpectrum.uniforms.u_wind.value.set( windX, windY );
					materialInitialSpectrum.uniforms.u_size.value = size;

					renderer.setRenderTarget( initialSpectrumFramebuffer );
					renderer.clear();
					renderer.render( simScene, simCamera );
				};

				function generateInitialPhaseTexture()
				{
					var initialPhaseArray = new window.Float32Array( resolution * resolution * 4 );
					for ( var i = 0; i < resolution; i ++ )
					{
						for ( var j = 0; j < resolution; j ++ )
						{
							initialPhaseArray[ i * resolution * 4 + j * 4 + 0 ] = Math.random() * 2.0 * Math.PI;
							initialPhaseArray[ i * resolution * 4 + j * 4 + 1 ] = 0.0;
							initialPhaseArray[ i * resolution * 4 + j * 4 + 2 ] = 0.0;
							initialPhaseArray[ i * resolution * 4 + j * 4 + 3 ] = 0.0;
						}
					}
					var initialPhaseTexture = new THREE.DataTexture( initialPhaseArray, resolution, resolution, THREE.RGBAFormat );
					initialPhaseTexture.wrapS = THREE.ClampToEdgeWrapping;
					initialPhaseTexture.wrapT = THREE.ClampToEdgeWrapping;
					initialPhaseTexture.type = THREE.FloatType;  //not : HalfFloat ?
					initialPhaseTexture.needsUpdate = true;

					return initialPhaseTexture
				}

				function renderWhole()
				{
					//render WavePhase
					{
						simScene.overrideMaterial = materialPhase;

						if( initial )
						{
							materialPhase.uniforms.u_phases.value = generateInitialPhaseTexture();

							initial = false;
						}
						else
						{
							materialPhase.uniforms.u_phases.value = pingPhase ? pingPhaseFramebuffer.texture : pongPhaseFramebuffer.texture;
							// count++
							// if(count % 60 === 0)
							// 	console.log( pingPhaseFramebuffer.texture )
						}

						materialPhase.uniforms.u_deltaTime.value = frameDelta;

						materialPhase.uniforms.u_size.value = size;
						renderer.setRenderTarget( pingPhase ? pongPhaseFramebuffer : pingPhaseFramebuffer );
						renderer.render( simScene, simCamera );
						pingPhase = ! pingPhase;

					};

					//render Spectrum
					{
						simScene.overrideMaterial = materialSpectrum;

						materialSpectrum.uniforms.u_initialSpectrum.value = initialSpectrumFramebuffer.texture;
						materialSpectrum.uniforms.u_phases.value = pingPhase ? pingPhaseFramebuffer.texture : pongPhaseFramebuffer.texture;
						materialSpectrum.uniforms.u_choppiness.value = choppiness;
						materialSpectrum.uniforms.u_size.value = size;

						renderer.setRenderTarget( spectrumFramebuffer );
						renderer.render( simScene, simCamera );
					};

					//render SpectrumFFT
					{
						simScene.overrideMaterial = materialWindHorizontal;

						// GPU FFT using Stockham formulation
						var iterations = Math.log( resolution ) / Math.log( 2 ); // log2
						for ( var i = 0; i < iterations; i ++ )
						{
							if ( i === 0 )
							{
								materialWindHorizontal.uniforms.u_input.value = spectrumFramebuffer.texture;
								materialWindHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );

								renderer.setRenderTarget( pingTransformFramebuffer );
								renderer.render( simScene, simCamera );

							} else if ( i % 2 === 1 )
							{
								materialWindHorizontal.uniforms.u_input.value = pingTransformFramebuffer.texture;
								materialWindHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );

								renderer.setRenderTarget( pongTransformFramebuffer );
								renderer.render( simScene, simCamera );

							} else
							{
								materialWindHorizontal.uniforms.u_input.value = pongTransformFramebuffer.texture;
								materialWindHorizontal.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );

								renderer.setRenderTarget( pingTransformFramebuffer );
								renderer.render( simScene, simCamera );
							}
						}

						simScene.overrideMaterial = materialWindVertical;

						for ( var i = iterations; i < iterations * 2; i ++ )
						{
							if ( i === iterations * 2 - 1 )
							{
								materialWindVertical.uniforms.u_input.value = ( iterations % 2 === 0 ) ? pingTransformFramebuffer.texture : pongTransformFramebuffer.texture;
								materialWindVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );

								renderer.setRenderTarget( displacementMapFramebuffer );
								renderer.render( simScene, simCamera );
							}
							else if ( i % 2 === 1 )
							{
								materialWindVertical.uniforms.u_input.value = pingTransformFramebuffer.texture;
								materialWindVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );

								renderer.setRenderTarget( pongTransformFramebuffer );
								renderer.render( simScene, simCamera );
							}
							else
							{
								materialWindVertical.uniforms.u_input.value = pongTransformFramebuffer.texture;
								materialWindVertical.uniforms.u_subtransformSize.value = Math.pow( 2, ( i % ( iterations ) ) + 1 );

								renderer.setRenderTarget( pingTransformFramebuffer );
								renderer.render( simScene, simCamera );
							}
						}
					};

					//render NormalMap
					{
						simScene.overrideMaterial = materialNormal;

						if ( changed ) materialNormal.uniforms.u_size.value = size;
						materialNormal.uniforms.u_displacementMap.value = displacementMapFramebuffer.texture;

						renderer.setRenderTarget( normalMapFramebuffer );
						renderer.clear();
						renderer.render( simScene, simCamera );
					};

					simScene.overrideMaterial = null;
				}

				return updateSimulation;
			};

			let updateSimulation = THREE.Ocean( renderer, camera, scene );

			let a = new THREE.Mesh( new THREE.SphereGeometry(64,50,50) )
			scene.add(a)

			renderer.setAnimationLoop( function()
			{
				frameDelta = clock.getDelta()

				updateSimulation();

				renderer.render( scene, camera );
			})

		</script>
	</body>
</html>
