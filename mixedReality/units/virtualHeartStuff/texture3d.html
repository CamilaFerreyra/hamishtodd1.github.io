<!--
	Picture neurons as little thermometers (make me feel old though, everyone has digital ones)
	Can we make a circuit that can calculate 2 + 2 = 4?
-->

<html><head>
<!DOCTYPE html>
<html lang="en">
<head>
	<me ta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="https://threejs.org/examples/main.css">
</head>

<script src="CanvasMatrix.js" type="text/javascript"></script>

<script src="../../lib/three.js"></script>
<script src="../../lib/nrrdLoader.js"></script>

<script>
// function init()
// {
// 	let scene = new THREE.Scene();

// 	let canvas = document.createElement( 'canvas' );
// 	let context = canvas.getContext( 'webgl2' );
// 	let renderer = new THREE.WebGLRenderer( { canvas: canvas, context: context } );
// 	renderer.setPixelRatio( window.devicePixelRatio );
// 	renderer.setSize( window.innerWidth, window.innerHeight );
// 	document.body.appendChild( renderer.domElement );

// 	// does not work with perspective, may have to do that yourself
// 	let frustumHeight = 512;
// 	let aspect = window.innerWidth / window.innerHeight;
// 	let camera = new THREE.OrthographicCamera( - frustumHeight * aspect / 2, frustumHeight * aspect / 2, frustumHeight / 2, - frustumHeight / 2, 1, 1000 );
// 	camera.position.set( 0, 0, 128 )

// 	new THREE.NRRDLoader().load( "../../data/stent.nrrd", function ( volume )
// 	{
// 		// We have scalars, so we put our data in the red channel.
// 		// THREEJS will select R32F (33326) based on the RedFormat and FloatType.
// 		// Also see https://www.khronos.org/registry/webgl/specs/latest/2.0/#TEXTURE_TYPES_FORMATS_FROM_DOM_ELEMENTS_TABLE
// 		let texture = new THREE.DataTexture3D( volume.data, volume.xLength, volume.yLength, volume.zLength );
// 		texture.format = THREE.RedFormat;
// 		texture.type = THREE.FloatType;
// 		texture.minFilter = texture.magFilter = THREE.LinearFilter;
// 		texture.unpackAlignment = 1;
// 		texture.needsUpdate = true;

// 		let uniforms = THREE.UniformsUtils.clone( THREE.VolumeRenderShader1.uniforms );
// 		uniforms[ "u_data" ].value = texture;
// 		uniforms[ "u_size" ].value.set( volume.xLength, volume.yLength, volume.zLength );
// 		uniforms[ "u_cmdata" ].value = new THREE.TextureLoader().load( '../../data/viridisColorMap.png', render )
// 		uniforms[ "u_clim" ].value.set( 0, 1 );

// 		let isContourSurface = 1
// 		uniforms[ "u_renderstyle" ].value = isContourSurface
// 		uniforms[ "u_isolevel" ].value = 0.15

// 		let box = new THREE.Mesh( 
// 			new THREE.BoxBufferGeometry( volume.xLength, volume.yLength, volume.zLength ),
// 			new THREE.ShaderMaterial( {
// 				uniforms: uniforms,
// 				vertexShader: THREE.VolumeRenderShader1.vertexShader,
// 				fragmentShader: THREE.VolumeRenderShader1.fragmentShader,
// 				side: THREE.BackSide // The volume shader uses the backface as its "reference point"
// 			} ) );
// 		box.geometry.translate( volume.xLength / 2 - 0.5, volume.yLength / 2 - 0.5, volume.zLength / 2 - 0.5 );
// 		box.position.sub( new THREE.Vector3( volume.xLength / 2 - 0.5, volume.yLength / 2 - 0.5, volume.zLength / 2 - 0.5 ) );
// 		scene.add( box );

// 		function render()
// 		{
// 			renderer.render( scene, camera );
// 		}
// 		render();

// 	} );
// }

const vertexShader = `#version 300 es
uniform mat4 objectMatrix;
uniform mat4 projectionMatrix;
uniform float pointSize;
uniform highp sampler3D uTS;
out vec2 color;
void main(void)
{
	ivec3 pos = ivec3(gl_InstanceID & 127,
		(gl_InstanceID>>7) & 127, gl_InstanceID>>14);
	vec2 t = texelFetch(uTS, pos, 0 ).rg;
	if (t.r < .6)
	{
		gl_Position = vec4(1000.,0.,0.,1.);
		return;
	}
	color = t;
	vec4 p = objectMatrix * vec4(pos, 1);
	gl_Position = projectionMatrix * p;
	gl_PointSize = -pointSize/p.z;
}
`;
 
const fragmentShader = `#version 300 es
precision highp float;
in vec2 color;
out vec4 FragColor;
void main(void)
{
	FragColor = vec4(color, 0., 1.);
}
`;

//note it is not this that puts it in the actual location
const simulationVertexShader = `#version 300 es
layout (location = 1) in vec2 aPos2;
out vec2 locationInLayer;
void main(void)
{
	gl_Position = vec4(aPos2, 0., 1.);
	locationInLayer = .5*aPos2 + .5;
}
`;

const simulationFragmentShader = `#version 300 es
precision highp float;

uniform highp sampler3D wholeTexture;

uniform float layerElevation;
in vec2 locationInLayer;
out vec2 FragColor;

const float a = .8, b = .001, dt = .05* .02, eps = .007, h = 0.2 * 0.607;
const float inverseEpsilonDeltaT = dt/eps, bOverA = b/a, inverseHSquaredDeltaT = dt/(h*h);

const float dimension = 128.;
const float d = 1./dimension;

void main(void)
{
	vec4 t = texture(wholeTexture, vec3(locationInLayer, layerElevation)); //just reading the texture
	float u = t.r;
	float v = t.g;

	float uth = v/a + bOverA;

	float partWay = inverseEpsilonDeltaT * (u - uth);

	float uNew;
	if ( u <= uth)
	{
		//quench
		uNew = u / (1. - partWay*(1. - u));
	}
	else
	{
		partWay *= u;
		uNew = (partWay + u) / (partWay + 1.);
	}

	uNew += 
		(	texture(wholeTexture, vec3( locationInLayer.x,     locationInLayer.y + d, layerElevation    ) ).r +
			texture(wholeTexture, vec3( locationInLayer.x,     locationInLayer.y - d, layerElevation    ) ).r +
			texture(wholeTexture, vec3( locationInLayer.x,     locationInLayer.y,     layerElevation + d) ).r +
			texture(wholeTexture, vec3( locationInLayer.x,     locationInLayer.y,     layerElevation - d) ).r +
			texture(wholeTexture, vec3( locationInLayer.x + d, locationInLayer.y,     layerElevation    ) ).r +
			texture(wholeTexture, vec3( locationInLayer.x - d, locationInLayer.y,     layerElevation    ) ).r
			- 6. * u ) //normalization of the 6 terms above
			* inverseHSquaredDeltaT;

	float vNew = v + (u - v) * dt;
	FragColor = vec2(uNew, vNew );
}
`;
 
function createShader(gl, type, source)
{
	var shader = gl.createShader(type);
	gl.shaderSource(shader, source);
	gl.compileShader(shader);
	if( gl.getShaderParameter(shader, gl.COMPILE_STATUS) )
	{
		return shader;
	}
	alert( gl.getShaderInfoLog(shader));
	gl.deleteShader(shader);
}

function init2()
{
	let canvas = document.createElement( 'canvas' );
	document.body.appendChild( canvas )
	gl = canvas.getContext("webgl2")

	let dimension = 128

	var ext = gl.getExtension("EXT_color_buffer_float")
	let c_w = window.innerWidth - 50;
	let c_h = window.innerHeight - 10
	canvas.width = c_w;
	canvas.height = c_h
	gl.enable(gl.DEPTH_TEST)
	gl.depthFunc(gl.LEQUAL)
	gl.clearDepth(1.0)
	gl.clearColor(0, 0, 0, 1)

	let drawingProgram = gl.createProgram()
	{
		gl.attachShader(drawingProgram, createShader( gl, gl.VERTEX_SHADER, vertexShader))
		gl.attachShader(drawingProgram, createShader( gl, gl.FRAGMENT_SHADER, fragmentShader))
		gl.linkProgram(drawingProgram)
		gl.useProgram(drawingProgram)

		var projectionMatrix = new CanvasMatrix4()
		projectionMatrix.perspective(45, c_w/c_h, .1, 100)
		gl.uniformMatrix4fv( 
			gl.getUniformLocation(drawingProgram,"projectionMatrix"), false,
			new Float32Array(projectionMatrix.getAsArray()) )
		gl.uniform1f(gl.getUniformLocation(drawingProgram, "pointSize"), .01*c_h)

		let objectMatrixPointer = gl.getUniformLocation(drawingProgram,"objectMatrix")
		let objectMatrix = new CanvasMatrix4()
		objectMatrix.makeIdentity()
		objectMatrix.scale(1/dimension, 1/dimension, 1/dimension)
		objectMatrix.translate(-.5, -.5, -.5)
		objectMatrix.rotate(110, 0,1,0)
		objectMatrix.translate(0, 0, -2)

		function drawScene()
		{
			gl.viewport(0, 0, c_w, c_h)
			gl.bindFramebuffer(gl.FRAMEBUFFER, null)
			gl.useProgram(drawingProgram)

			gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT )
			gl.uniformMatrix4fv( objectMatrixPointer, false, new Float32Array( objectMatrix.getAsArray() ) )
			gl.drawArraysInstanced( gl.POINTS, 0, 1, dimension*dimension*dimension)
		}
	}

	let initialState = new Float32Array(2*dimension*dimension*dimension)
	for(var k = 0; k < 3*dimension/4; k++)
	for(var i = 0; i < 3*dimension/4; i++)
	{
		initialState[2*(i + k*dimension*dimension + dimension*(dimension/2 + 19))] = 1
		initialState[2*(i + k*dimension*dimension + dimension*(dimension/2 + 20))] = 1
		initialState[2*(i + k*dimension*dimension + dimension*(dimension/2 + 21)) + 1] = 1
		initialState[2*(i + k*dimension*dimension + dimension*(dimension/2 + 22)) + 1] = 1
		initialState[2*(i + k*dimension*dimension + dimension*(dimension/2 + 23)) + 1] = 1
		initialState[2*(i + k*dimension*dimension + dimension*(dimension/2 + 24)) + 1] = 1
	}
	function TextureWithInitialState()
	{
		let t = gl.createTexture()
		gl.bindTexture(gl.TEXTURE_3D, t)
		gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1)
		gl.texImage3D(gl.TEXTURE_3D, 0, gl.RG32F, dimension,dimension,dimension, 0, gl.RG, gl.FLOAT, initialState)
		gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
		gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
		gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
		gl.texParameteri(gl.TEXTURE_3D, gl.TEXTURE_WRAP_R, gl.CLAMP_TO_EDGE)

		return t;
	}

	let texture = TextureWithInitialState()
	let texture2 = TextureWithInitialState()
	let fb = gl.createFramebuffer()
	let fb2 = gl.createFramebuffer()

	let simulation = gl.createProgram()
	gl.attachShader(simulation, createShader( gl, gl.VERTEX_SHADER, simulationVertexShader))
	gl.attachShader(simulation, createShader( gl, gl.FRAGMENT_SHADER, simulationFragmentShader))
	let aPos2Loc = 1
	gl.linkProgram(simulation)
	gl.useProgram(simulation)
	let layerElevationPointer = gl.getUniformLocation(simulation, "layerElevation")
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer())
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW)
	gl.vertexAttribPointer(aPos2Loc, 2, gl.FLOAT, gl.FALSE, 0, 0)
	gl.enableVertexAttribArray( aPos2Loc )

	function stepTexture(textureToReadFrom, textureToWriteTo, frameBuffer)
	{
		gl.bindTexture(gl.TEXTURE_3D, textureToReadFrom)
		gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer)

		for(var i = 0; i < dimension; i++)
		{
			//set the layer
			gl.uniform1f(layerElevationPointer, i/dimension)
			gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0,
				textureToWriteTo,
				0, i)

			//use the shaders
			gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4)
		}
	}

	function loop()
	{
		gl.viewport(0,0,dimension,dimension) //it's divided into dimension x dimension layers
		gl.useProgram(simulation)

		//presumably two steps because you've got to step both u and v. Yet shader gets both?
		//maybe they're two steps of the simulation?
		stepTexture(texture, texture2, fb)
		stepTexture(texture2, texture, fb2)

		drawScene() //hopefully we can replace. So how does it get communicated in?
		requestAnimationFrame(loop)
	}

	loop()
}

</script>

</head>
<body onload="init();">
</body>
</html>